#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process')

/**
 * Comprehensive Bundle Analysis and Reporting Script
 * 
 * This script generates detailed bundle reports including:
 * - Historical size tracking
 * - Performance impact analysis
 * - Dependency analysis
 * - Optimization suggestions
 * - CI/CD integration metrics
 */

const ANALYSIS_DIR = 'bundle-analysis'
const REPORTS_DIR = path.join(ANALYSIS_DIR, 'reports')
const HISTORY_FILE = path.join(ANALYSIS_DIR, 'history.json')

class BundleReporter {
  constructor() {
    this.currentAnalysis = null
    this.history = this.loadHistory()
  }

  /**
   * Generate comprehensive bundle report
   */
  async generateReport() {
    console.log('üìä Generating comprehensive bundle report...\n')

    try {
      // Load latest analysis
      this.loadLatestAnalysis()

      // Ensure reports directory exists
      if (!fs.existsSync(REPORTS_DIR)) {
        fs.mkdirSync(REPORTS_DIR, { recursive: true })
      }

      // Generate different report formats
      await this.generateMarkdownReport()
      await this.generateJSONReport()
      await this.generateHTMLReport()
      await this.updateHistory()

      console.log('‚úÖ Bundle reports generated successfully!')
      console.log(`üìÅ Reports saved to: ${REPORTS_DIR}`)

    } catch (error) {
      console.error('‚ùå Report generation failed:', error.message)
      process.exit(1)
    }
  }

  /**
   * Load latest bundle analysis
   */
  loadLatestAnalysis() {
    const latestPath = path.join(ANALYSIS_DIR, 'latest.json')
    
    if (!fs.existsSync(latestPath)) {
      throw new Error('No analysis data found. Run `npm run bundle:size` first.')
    }

    this.currentAnalysis = JSON.parse(fs.readFileSync(latestPath, 'utf8'))
  }

  /**
   * Load historical data
   */
  loadHistory() {
    if (fs.existsSync(HISTORY_FILE)) {
      try {
        return JSON.parse(fs.readFileSync(HISTORY_FILE, 'utf8'))
      } catch (error) {
        console.warn('‚ö†Ô∏è  Could not load history file, starting fresh')
      }
    }
    
    return {
      entries: [],
      metadata: {
        created: new Date().toISOString(),
        lastUpdated: null
      }
    }
  }

  /**
   * Generate Markdown report
   */
  async generateMarkdownReport() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `bundle-report-${timestamp}.md`
    const filepath = path.join(REPORTS_DIR, filename)

    const report = this.buildMarkdownReport()
    fs.writeFileSync(filepath, report)

    // Also save as latest
    fs.writeFileSync(path.join(REPORTS_DIR, 'latest-report.md'), report)

    console.log(`üìù Markdown report: ${filename}`)
  }

  /**
   * Build Markdown report content
   */
  buildMarkdownReport() {
    const analysis = this.currentAnalysis
    const gitBranch = this.getGitBranch()
    const gitCommit = this.getGitCommit()

    return `# Bundle Analysis Report

Generated: ${new Date(analysis.timestamp).toLocaleString()}  
Branch: \`${gitBranch}\`  
Commit: \`${gitCommit}\`  

## üìä Summary

| Metric | Value |
|--------|-------|
| **Total Bundle Size** | ${this.formatBytes(analysis.totalSize)} |
| **Number of Chunks** | ${this.getTotalChunks()} |
| **Pages Analyzed** | ${Object.keys(analysis.pages).length} |
| **Warnings** | ${analysis.warnings.length} |
| **Recommendations** | ${analysis.recommendations.length} |

## üì¶ Size Breakdown

${this.buildSizeBreakdownTable()}

## üìÑ Page Analysis

${this.buildPageAnalysisTable()}

## üîç Largest Files

${this.buildLargestFilesTable()}

## ‚ö†Ô∏è Warnings

${this.buildWarningsSection()}

## üí° Optimization Recommendations

${this.buildRecommendationsSection()}

## üìà Historical Comparison

${this.buildHistoricalComparison()}

## üõ†Ô∏è Next Steps

Based on this analysis, consider the following actions:

${this.buildNextStepsSection()}

---

*Report generated by Bundle Analyzer v1.0*
`
  }

  /**
   * Build size breakdown table
   */
  buildSizeBreakdownTable() {
    const chunks = this.currentAnalysis.chunks
    
    let table = '| Category | Size | Files | Percentage |\n'
    table += '|----------|------|-------|------------|\n'

    const totalSize = this.currentAnalysis.totalSize
    
    for (const [category, info] of Object.entries(chunks)) {
      const percentage = ((info.totalSize / totalSize) * 100).toFixed(1)
      table += `| ${category} | ${this.formatBytes(info.totalSize)} | ${info.count} | ${percentage}% |\n`
    }

    return table
  }

  /**
   * Build page analysis table
   */
  buildPageAnalysisTable() {
    const pages = this.currentAnalysis.pages
    const pageEntries = Object.entries(pages)
      .filter(([, info]) => info.size > 0)
      .sort(([, a], [, b]) => (b.size || 0) - (a.size || 0))
      .slice(0, 15)

    if (pageEntries.length === 0) {
      return '*No page data available*'
    }

    let table = '| Page | Size | Chunks |\n'
    table += '|------|------|--------|\n'

    for (const [page, info] of pageEntries) {
      const chunksCount = info.chunks ? info.chunks.length : 0
      table += `| \`${page}\` | ${this.formatBytes(info.size)} | ${chunksCount} |\n`
    }

    return table
  }

  /**
   * Build largest files table
   */
  buildLargestFilesTable() {
    const allFiles = []
    for (const category of Object.values(this.currentAnalysis.chunks)) {
      allFiles.push(...category.files)
    }
    
    const largest = allFiles
      .sort((a, b) => b.size - a.size)
      .slice(0, 15)

    let table = '| File | Size | Category |\n'
    table += '|------|------|----------|\n'

    for (const file of largest) {
      const category = this.getFileCategory(file.name)
      table += `| \`${file.name}\` | ${file.sizeFormatted} | ${category} |\n`
    }

    return table
  }

  /**
   * Build warnings section
   */
  buildWarningsSection() {
    const warnings = this.currentAnalysis.warnings

    if (warnings.length === 0) {
      return '*No warnings detected* ‚úÖ'
    }

    let section = ''
    for (const warning of warnings) {
      section += `- **${warning.type}**: ${warning.message}\n`
    }

    return section
  }

  /**
   * Build recommendations section
   */
  buildRecommendationsSection() {
    const recommendations = this.currentAnalysis.recommendations

    if (recommendations.length === 0) {
      return '*No specific recommendations at this time* ‚úÖ'
    }

    let section = ''
    for (const rec of recommendations) {
      const priority = rec.priority === 'high' ? 'üî¥ HIGH' : 'üü° MEDIUM'
      section += `### ${priority}: ${rec.type}\n\n`
      section += `**Issue**: ${rec.message}\n\n`
      section += `**Suggestion**: ${rec.suggestion}\n\n`
      
      if (rec.files && rec.files.length > 0) {
        section += '**Affected files**:\n'
        for (const file of rec.files.slice(0, 5)) {
          section += `- \`${file}\`\n`
        }
        if (rec.files.length > 5) {
          section += `- *...and ${rec.files.length - 5} more*\n`
        }
      }
      
      section += '\n'
    }

    return section
  }

  /**
   * Build historical comparison
   */
  buildHistoricalComparison() {
    if (this.history.entries.length === 0) {
      return '*No historical data available*'
    }

    const latest = this.history.entries[this.history.entries.length - 1]
    const current = this.currentAnalysis

    const sizeDiff = current.totalSize - latest.totalSize
    const sizeChange = sizeDiff >= 0 ? `+${this.formatBytes(sizeDiff)}` : this.formatBytes(sizeDiff)
    const sizeChangePercent = ((sizeDiff / latest.totalSize) * 100).toFixed(1)

    let section = `### Size Comparison (vs. previous build)\n\n`
    section += `| Metric | Previous | Current | Change |\n`
    section += `|--------|----------|---------|--------|\n`
    section += `| Total Size | ${this.formatBytes(latest.totalSize)} | ${this.formatBytes(current.totalSize)} | ${sizeChange} (${sizeChangePercent}%) |\n`

    // Size trend over last 10 builds
    if (this.history.entries.length >= 3) {
      section += `\n### Size Trend (last ${Math.min(10, this.history.entries.length)} builds)\n\n`
      
      const recentEntries = this.history.entries.slice(-10)
      section += '```\n'
      for (const entry of recentEntries) {
        const date = new Date(entry.timestamp).toLocaleDateString()
        const size = this.formatBytes(entry.totalSize)
        section += `${date}: ${size}\n`
      }
      section += '```\n'
    }

    return section
  }

  /**
   * Build next steps section
   */
  buildNextStepsSection() {
    const analysis = this.currentAnalysis
    const steps = []

    // Size-based recommendations
    if (analysis.totalSize > 1024 * 1024) { // > 1MB
      steps.push('üéØ **Reduce bundle size**: Total size exceeds 1MB. Consider code splitting and lazy loading.')
    }

    // Warning-based recommendations
    if (analysis.warnings.length > 0) {
      steps.push('‚ö†Ô∏è **Address warnings**: Review and fix the warnings listed above.')
    }

    // High priority recommendations
    const highPriorityRecs = analysis.recommendations.filter(r => r.priority === 'high')
    if (highPriorityRecs.length > 0) {
      steps.push('üî¥ **High priority optimizations**: Address high-priority recommendations first.')
    }

    // General recommendations
    steps.push('üìä **Monitor regularly**: Set up automated bundle size monitoring in CI/CD.')
    steps.push('üîç **Analyze dependencies**: Review large dependencies for optimization opportunities.')

    if (steps.length === 0) {
      return '‚úÖ Bundle optimization looks good! Continue monitoring for future changes.'
    }

    return steps.map((step, i) => `${i + 1}. ${step}`).join('\n')
  }

  /**
   * Generate detailed JSON report
   */
  async generateJSONReport() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `bundle-report-${timestamp}.json`
    const filepath = path.join(REPORTS_DIR, filename)

    const report = {
      metadata: {
        generatedAt: new Date().toISOString(),
        gitBranch: this.getGitBranch(),
        gitCommit: this.getGitCommit(),
        nodeVersion: process.version,
        platform: process.platform
      },
      analysis: this.currentAnalysis,
      recommendations: this.generateDetailedRecommendations(),
      performance: this.calculatePerformanceMetrics(),
      comparison: this.getHistoricalComparison()
    }

    fs.writeFileSync(filepath, JSON.stringify(report, null, 2))
    fs.writeFileSync(path.join(REPORTS_DIR, 'latest-report.json'), JSON.stringify(report, null, 2))

    console.log(`üìã JSON report: ${filename}`)
  }

  /**
   * Generate simple HTML report
   */
  async generateHTMLReport() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `bundle-report-${timestamp}.html`
    const filepath = path.join(REPORTS_DIR, filename)

    const html = this.buildHTMLReport()
    fs.writeFileSync(filepath, html)
    fs.writeFileSync(path.join(REPORTS_DIR, 'latest-report.html'), html)

    console.log(`üåê HTML report: ${filename}`)
  }

  /**
   * Build HTML report
   */
  buildHTMLReport() {
    const analysis = this.currentAnalysis
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bundle Analysis Report</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #333; border-bottom: 2px solid #007ACC; padding-bottom: 10px; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .metric { background: #f8f9fa; border-radius: 6px; padding: 15px; text-align: center; border-left: 4px solid #007ACC; }
        .metric-value { font-size: 1.8em; font-weight: bold; color: #007ACC; }
        .metric-label { color: #666; font-size: 0.9em; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background: #f8f9fa; font-weight: 600; }
        .warning { background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 10px 0; }
        .recommendation { background: #d1ecf1; border-left: 4px solid #17a2b8; padding: 10px; margin: 10px 0; }
        .high-priority { border-left-color: #dc3545; background: #f8d7da; }
        code { background: #f1f3f4; padding: 2px 4px; border-radius: 3px; font-family: 'Monaco', 'Consolas', monospace; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Bundle Analysis Report</h1>
        <p><strong>Generated:</strong> ${new Date(analysis.timestamp).toLocaleString()}</p>
        
        <div class="summary">
            <div class="metric">
                <div class="metric-value">${this.formatBytes(analysis.totalSize)}</div>
                <div class="metric-label">Total Bundle Size</div>
            </div>
            <div class="metric">
                <div class="metric-value">${this.getTotalChunks()}</div>
                <div class="metric-label">Total Chunks</div>
            </div>
            <div class="metric">
                <div class="metric-value">${Object.keys(analysis.pages).length}</div>
                <div class="metric-label">Pages</div>
            </div>
            <div class="metric">
                <div class="metric-value">${analysis.warnings.length}</div>
                <div class="metric-label">Warnings</div>
            </div>
        </div>

        <h2>üì¶ Size Breakdown</h2>
        <table>
            <thead>
                <tr><th>Category</th><th>Size</th><th>Files</th><th>Percentage</th></tr>
            </thead>
            <tbody>
                ${Object.entries(analysis.chunks).map(([category, info]) => {
                  const percentage = ((info.totalSize / analysis.totalSize) * 100).toFixed(1)
                  return `<tr><td>${category}</td><td>${this.formatBytes(info.totalSize)}</td><td>${info.count}</td><td>${percentage}%</td></tr>`
                }).join('')}
            </tbody>
        </table>

        ${analysis.warnings.length > 0 ? `
        <h2>‚ö†Ô∏è Warnings</h2>
        ${analysis.warnings.map(w => `<div class="warning"><strong>${w.type}:</strong> ${w.message}</div>`).join('')}
        ` : ''}

        ${analysis.recommendations.length > 0 ? `
        <h2>üí° Recommendations</h2>
        ${analysis.recommendations.map(r => `
        <div class="recommendation ${r.priority === 'high' ? 'high-priority' : ''}">
            <strong>${r.priority === 'high' ? 'üî¥' : 'üü°'} ${r.type}:</strong> ${r.message}<br>
            <em>${r.suggestion}</em>
        </div>`).join('')}
        ` : ''}

        <p style="text-align: center; color: #666; margin-top: 40px; font-size: 0.9em;">
            Generated by Bundle Analyzer ‚Ä¢ ${new Date().toLocaleDateString()}
        </p>
    </div>
</body>
</html>`
  }

  /**
   * Update historical tracking
   */
  updateHistory() {
    const entry = {
      timestamp: this.currentAnalysis.timestamp,
      totalSize: this.currentAnalysis.totalSize,
      chunkCount: this.getTotalChunks(),
      warningCount: this.currentAnalysis.warnings.length,
      gitCommit: this.getGitCommit(),
      gitBranch: this.getGitBranch()
    }

    this.history.entries.push(entry)
    this.history.metadata.lastUpdated = new Date().toISOString()

    // Keep only last 50 entries
    if (this.history.entries.length > 50) {
      this.history.entries = this.history.entries.slice(-50)
    }

    fs.writeFileSync(HISTORY_FILE, JSON.stringify(this.history, null, 2))
  }

  /**
   * Get detailed recommendations
   */
  generateDetailedRecommendations() {
    // This would contain more detailed analysis and suggestions
    return this.currentAnalysis.recommendations
  }

  /**
   * Calculate performance metrics
   */
  calculatePerformanceMetrics() {
    const analysis = this.currentAnalysis
    
    // Estimated load times based on different connection speeds
    const connectionSpeeds = {
      '3G': 1.6 * 1024 * 1024 / 8, // 1.6 Mbps in bytes per second
      '4G': 10 * 1024 * 1024 / 8,  // 10 Mbps in bytes per second
      'Cable': 25 * 1024 * 1024 / 8 // 25 Mbps in bytes per second
    }

    const loadTimes = {}
    for (const [speed, bytesPerSecond] of Object.entries(connectionSpeeds)) {
      loadTimes[speed] = (analysis.totalSize / bytesPerSecond).toFixed(2) + 's'
    }

    return {
      estimatedLoadTimes: loadTimes,
      bundleSizeRating: this.getBundleSizeRating(analysis.totalSize),
      performanceScore: this.calculatePerformanceScore()
    }
  }

  /**
   * Get bundle size rating
   */
  getBundleSizeRating(size) {
    if (size < 100 * 1024) return 'Excellent'
    if (size < 250 * 1024) return 'Good'
    if (size < 500 * 1024) return 'Fair'
    if (size < 1024 * 1024) return 'Poor'
    return 'Critical'
  }

  /**
   * Calculate performance score
   */
  calculatePerformanceScore() {
    const analysis = this.currentAnalysis
    let score = 100

    // Deduct points for large bundle size
    if (analysis.totalSize > 250 * 1024) score -= 20
    if (analysis.totalSize > 500 * 1024) score -= 30
    if (analysis.totalSize > 1024 * 1024) score -= 40

    // Deduct points for warnings
    score -= analysis.warnings.length * 5

    // Deduct points for high priority recommendations
    const highPriorityRecs = analysis.recommendations.filter(r => r.priority === 'high')
    score -= highPriorityRecs.length * 15

    return Math.max(0, score)
  }

  /**
   * Get historical comparison
   */
  getHistoricalComparison() {
    if (this.history.entries.length === 0) {
      return null
    }

    const latest = this.history.entries[this.history.entries.length - 1]
    const current = this.currentAnalysis

    return {
      previousSize: latest.totalSize,
      currentSize: current.totalSize,
      sizeDifference: current.totalSize - latest.totalSize,
      percentageChange: ((current.totalSize - latest.totalSize) / latest.totalSize * 100).toFixed(2)
    }
  }

  /**
   * Helper methods
   */
  getTotalChunks() {
    return Object.values(this.currentAnalysis.chunks)
      .reduce((total, chunk) => total + chunk.count, 0)
  }

  getFileCategory(filename) {
    const ext = path.extname(filename)
    const categories = {
      '.js': 'JavaScript',
      '.css': 'CSS',
      '.woff': 'Font',
      '.woff2': 'Font',
      '.png': 'Image',
      '.jpg': 'Image',
      '.svg': 'Image',
      '.json': 'Data'
    }
    return categories[ext] || 'Other'
  }

  getGitBranch() {
    try {
      return execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim()
    } catch {
      return 'unknown'
    }
  }

  getGitCommit() {
    try {
      return execSync('git rev-parse --short HEAD', { encoding: 'utf8' }).trim()
    } catch {
      return 'unknown'
    }
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B'
    const k = 1024
    const sizes = ['B', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`
  }
}

// Run if called directly
if (require.main === module) {
  const reporter = new BundleReporter()
  reporter.generateReport().catch(error => {
    console.error('Fatal error:', error)
    process.exit(1)
  })
}

module.exports = BundleReporter